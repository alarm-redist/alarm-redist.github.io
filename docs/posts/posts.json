[
  {
    "path": "posts/2021-04-02-redist-300/",
    "title": "redist 3.0.0",
    "description": "A major release brings new algorithms, new workflows, and significant \nusability improvements.",
    "author": [
      {
        "name": "Cory McCartan",
        "url": "https://corymccartan.github.io/"
      },
      {
        "name": "Christopher Kenny",
        "url": "https://www.christophertkenny.com/"
      }
    ],
    "date": "2021-04-02",
    "categories": [],
    "contents": "\r\nThe ALARM Project is excited to announce the release of redist 3.0.0. This release brings with it new algorithms and major new workflow improvements, making redistricting analysis broadly accessible to data scientists everywhere.\r\n\r\nNew Features\r\nThis release includes far too many changes to list comprehensively. Key improvements and new features include:\r\nNew tidy interface, including new redist_map and redist_plans objects\r\nMerge-split MCMC now available in redist_mergesplit()\r\nShort burst MCMC optimization now available in redist_shortburst() along with scoring functions\r\nImproved Flip MCMC interface and performance improvements\r\nNew support for larger simulation size limits\r\nFunctions to freeze parts of a map and extract district cores\r\nNew VRA constraint\r\nMany new plotting functions\r\nConsistent function and argument names\r\nNew partisanship and compactnes metrics\r\nPerformance improvements to compactness calculations\r\nPlan comparison and classification in compare_plans() and classify_plans()\r\nNew piowa](/redist/reference/iowa.html) dataset and cleaned-up package data\r\nTo begin exploring the new features, check out the new Get Started vignette.\r\nWorkflow Example: North Carolina\r\nTo demonstrate the new redist workflow, we’ll run through a basic analysis of the 2017 congressional districts of the state of North Carolina, which were struck down as an unconstitutional partisan gerrymander in 2019.\r\nNew workflow\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(redist)\r\n\r\ndownload.file(\"https://github.com/alarm-redist/redist-data/raw/main/data/nc.rds\",\r\n              data_path <- tempfile())\r\nnc_shp <- readRDS(data_path) %>%\r\n    select(vtd:vap, el14g_uss_r:geometry)\r\n\r\n\r\n\r\nUnder the new workflow, a redistricting analysis begins with a redist_map object, which defines the basic parameters of the redistricting problem. The redist_map() constructor builds the precinct adjacency graph which is required for redistricting simulation, and stores relevant metadata, such as the desired population parity tolerance and a reference to the existing districts. It also comes with helpful plotting functions.\r\n\r\n\r\nnc = redist_map(nc_shp, existing_plan=cd_17, pop_tol=0.01)\r\nprint(nc)\r\n\r\n\r\nA redist_map object with 2692 units and 15 fields\r\nTo be partitioned into 13 districts with population between 733,498.7 - 1.0% and 733,498.7 + 1.0%\r\nWith geometry:\r\n    bbox:           xmin: 406819.6 ymin: 2696.2 xmax: 3070217 ymax: 1043629\r\n    projected CRS:  NAD83(HARN) / North Carolina (ftUS)\r\n# A tibble: 2,692 x 15\r\n   vtd       county   pop   vap el14g_uss_r el14g_uss_d el14g_uss_l\r\n * <chr>     <chr>  <int> <int>       <int>       <int>       <int>\r\n 1 3700106W  37001   1973  1505         181         182          17\r\n 2 3700112E  37001   3391  2503         180         271          21\r\n 3 3700112W  37001   2744  2156         457         481          42\r\n 4 3700106N  37001   4468  3167         231         466          31\r\n 5 37001126  37001   2038  1713         670         416          38\r\n 6 37001124  37001   2455  1948         491         391          33\r\n 7 370011210 37001   2802  2127         358         309          31\r\n 8 3700103N  37001   5712  4955        1063         853          53\r\n 9 3700102   37001   4491  3483        1246         313          62\r\n10 3700106E  37001   3113  2371         423         432          42\r\n# ... with 2,682 more rows, and 8 more variables: el14g_uss_wi <int>,\r\n#   el14g_uss_tot <int>, cd_13 <int>, cd_17 <int>, aland10 <dbl>,\r\n#   awater10 <dbl>, geometry <MULTIPOLYGON [US_survey_foot]>,\r\n#   adj <list>\r\n\r\nplot(nc, el14g_uss_d/(el14g_uss_d+el14g_uss_r)) +\r\n    scale_fill_gradient2(midpoint=0.5)\r\n\r\n\r\n\r\n\r\nOnce we’ve created a redist_map object, we can simulate redistricting plans.\r\n\r\n\r\nplans = redist_smc(nc, 1000, counties=county, silent=TRUE) # 1000 plans\r\nprint(plans)\r\n\r\n\r\n1000 sampled plans and 1 reference plan with 13 districts from a 2692-unit map,\r\n  drawn using Sequential Monte Carlo\r\nWith plans resampled from weights\r\nPlans matrix: num [1:2692, 1:1001] 6 6 6 6 6 6 6 6 6 6 ...\r\n# A tibble: 13,013 x 3\r\n   draw  district total_pop\r\n   <fct>    <int>     <dbl>\r\n 1 cd_17        1    733323\r\n 2 cd_17        2    734740\r\n 3 cd_17        3    732627\r\n 4 cd_17        4    733218\r\n 5 cd_17        5    733879\r\n 6 cd_17        6    733554\r\n 7 cd_17        7    734750\r\n 8 cd_17        8    734777\r\n 9 cd_17        9    731507\r\n10 cd_17       10    736057\r\n# ... with 13,003 more rows\r\n\r\nThe plans variable is a redist_plans object—a special container designed to make handling sets of redistricting plans painless. As the output above shows, plans contains the 1,000 samppled plans, plus the 2017 congressional districts. We can plot a few of these plans.\r\n\r\n\r\nredist.plot.plans(plans, draws=c(\"cd_17\", \"1\", \"2\", \"3\"), geom=nc)\r\n\r\n\r\n\r\n\r\nA redist_plans object makes it easy to compute plan and district summary statistics.\r\n\r\n\r\nplans = plans %>%\r\n    mutate(comp = distr_compactness(nc),\r\n           dem_share = group_frac(nc, el14g_uss_d, el14g_uss_d + el14g_uss_r))\r\nprint(plans)\r\n\r\n\r\n1000 sampled plans and 1 reference plan with 13 districts from a 2692-unit map,\r\n  drawn using Sequential Monte Carlo\r\nWith plans resampled from weights\r\nPlans matrix: num [1:2692, 1:1001] 6 6 6 6 6 6 6 6 6 6 ...\r\n# A tibble: 13,013 x 5\r\n   draw  district total_pop  comp dem_share\r\n   <fct>    <int>     <dbl> <dbl>     <dbl>\r\n 1 cd_17        1    733323 0.803     0.687\r\n 2 cd_17        2    734740 0.803     0.443\r\n 3 cd_17        3    732627 0.803     0.407\r\n 4 cd_17        4    733218 0.803     0.674\r\n 5 cd_17        5    733879 0.803     0.425\r\n 6 cd_17        6    733554 0.803     0.441\r\n 7 cd_17        7    734750 0.803     0.446\r\n 8 cd_17        8    734777 0.803     0.439\r\n 9 cd_17        9    731507 0.803     0.440\r\n10 cd_17       10    736057 0.803     0.419\r\n# ... with 13,003 more rows\r\n\r\nFrom there, we can quickly generate informative plots. First we check the compactness of the generated plans, and see that they are significantly more compact than the adopted 2017 plan.\r\n\r\n\r\nhist(plans, comp) +\r\n    labs(x=\"Compactness score (higher is more compact)\")\r\n\r\n\r\n\r\n\r\nNext, we look at the partisan implications of the 2017 plan. We plot the two-party Democratic vote share in each district, with districts sorted by this quantity. Each dot on the plot below is a district from one simulated plan, and the red lines show the values for the 2017 plan.\r\n\r\n\r\nredist.plot.distr_qtys(plans, dem_share, size=0.1)\r\n\r\n\r\n\r\n\r\nWe see immediately that the 2017 plan packs Democratic voters into the three most Democratic districts, and cracks them in the remaining 10 districts, leading to a durable 10–3 Republican-Democratic seat split (in an election which Democrats captured 49% of the statewide two-party vote). A clear partisan gerrymander.\r\nStudying districts 1, 2, and 4\r\nIf we want to study a specific set of districts, we can quickly filter() to the relevant map area and re-run the analysis. The redist_map() object will handle all appropriate adjustments to the adjacency graph, number of districts, and population tolerance (as is visible below).\r\n\r\n\r\nnc_sub = filter(nc, cd_17 %in% c(1, 2, 4))\r\nprint(nc_sub)\r\n\r\n\r\nA redist_map object with 571 units and 15 fields\r\nTo be partitioned into 3 districts with population between 733,760.3 - 1.035301% and 733,760.3 + 0.9639859%\r\nWith geometry:\r\n    bbox:           xmin: 1921644 ymin: 524882.4 xmax: 2784102 ymax: 1028248\r\n    projected CRS:  NAD83(HARN) / North Carolina (ftUS)\r\n# A tibble: 571 x 15\r\n   vtd     county   pop   vap el14g_uss_r el14g_uss_d el14g_uss_l\r\n * <chr>   <chr>  <int> <int>       <int>       <int>       <int>\r\n 1 37015C2 37015   2182  1707         174         503          13\r\n 2 37015M1 37015   1103   849         172         167           5\r\n 3 37015C1 37015   1229   986         229         184          11\r\n 4 37015MH 37015    992   811         146         254          12\r\n 5 37015W2 37015    966   764         286          47          20\r\n 6 37015W1 37015   7005  5703         596        1190          44\r\n 7 37015M2 37015   1290   983          99         239          16\r\n 8 37015SN 37015   1410  1025          63         327          11\r\n 9 37015WH 37015   1554  1274         292         262          12\r\n10 37015WD 37015   1409  1050          35         319           5\r\n# ... with 561 more rows, and 8 more variables: el14g_uss_wi <int>,\r\n#   el14g_uss_tot <int>, cd_13 <int>, cd_17 <int>, aland10 <dbl>,\r\n#   awater10 <dbl>, geometry <MULTIPOLYGON [US_survey_foot]>,\r\n#   adj <list>\r\n\r\nplot(nc_sub)\r\n\r\n\r\n\r\n\r\nOn this subset, too, the adopted 2017 plan is a significant outlier.\r\n\r\n\r\nplans_sub = redist_smc(nc_sub, 1000, counties=county, silent=T) %>%\r\n    mutate(dem_share = group_frac(nc_sub, el14g_uss_d, el14g_uss_d + el14g_uss_r))\r\nredist.plot.distr_qtys(plans_sub, dem_share, size=0.3)\r\n\r\n\r\n\r\n\r\nOld workflow\r\nIn comparison, the old workflow required significantly more steps and manual processing.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(redist)\r\n\r\ndownload.file(\"https://github.com/alarm-redist/redist-data/raw/main/data/nc.rds\",\r\n              data_path <- tempfile())\r\nnc_shp <- readRDS(data_path) %>%\r\n    select(vtd:vap, el14g_uss_r:geometry)\r\n\r\n\r\n\r\nOnce we’ve downloaded the data, we can start by building the adjacency graph.\r\n\r\n\r\nadj <- redist.adjacency(nc_shp)\r\n\r\n\r\n\r\nTime to first simulation was never really the issue, however each simulation required many inputs. redist_map objects keep track of the adj, total_pop, ndists, and pop_tol arguments, but in the older version, you had to specify each of these for every simulation. One of the quirky aspects of the older version was that counties needed to be a vector with values 1:n_counties, meaning that you had to manually transform it to use it and that only worked if the counties were contiguous.\r\n\r\n\r\nsims <- redist.smc(adj = adj, total_pop = nc_shp$pop, ndists = 13, pop_tol = 0.01,\r\n                   counties = match(nc_shp$county, unique(nc_shp$county)), nsims = 1000, \r\n                   silent = TRUE)\r\n\r\n\r\n\r\nOnce you finished simulating, setting up plots was always a hassle, as you needed to plot both the distribution of simulations and then compute the same metric separately for the reference plan, in this case that’s the 2017 congressional districts.\r\n\r\n\r\nmetrics <- redist.metrics(plans = sims$plans, measure = 'DVS', rvote = nc_shp$el14g_uss_r, nc_shp$el14g_uss_d)\r\n\r\nsorted <- metrics %>% \r\n  group_by(draw) %>% \r\n  arrange(DVS,.by_group = TRUE) %>% \r\n  mutate(district = 1:13) %>% \r\n  ungroup()\r\n\r\nreference_metrics <- redist.metrics(plans = nc_shp$cd_17, measure = 'DVS', rvote = nc_shp$el14g_uss_r, dvote = nc_shp$el14g_uss_d)\r\n\r\nsorted_reference <- reference_metrics %>% arrange(DVS) %>% mutate(district = 1:13)\r\n\r\n\r\n\r\nAnd then to plot the standard stacked boxplots, you would need to add the reference plan manually to the rest.\r\n\r\n\r\nsorted %>% ggplot(aes(x = district, y = DVS, group = district)) + \r\n  geom_boxplot() + \r\n  theme_minimal() + \r\n  labs(x = 'District, sorted by DVS') + \r\n  geom_segment(data = sorted_reference, size = 1,\r\n               aes(x = district - 0.35, xend = district + 0.35, yend = DVS, color = 'red')) + \r\n  scale_color_manual(name = '', values = c('red' = 'red'),\r\n  labels = c('ref'), guide = 'legend')\r\n\r\n\r\n\r\n\r\nStudying districts 1, 2, and 4\r\nThe steps between loading in data to your first simulation wasn’t terrible in the old version when you were working with the full map. However, when trying to work with subsets, it became messy.\r\nFirst you needed to subset the shape and then rebuild a new adjacency graph that only had the remaining precincts.\r\n\r\n\r\nsub <- nc_shp %>% filter(cd_17 %in% c(1, 2, 4))\r\nsub_adj <- redist.adjacency(sub)\r\n\r\n\r\n\r\nThen, if your target on the full map was 1%, you had to compute the equivalent on the subset map, as a 1% population deviation on a subset is often larger once recombined with the full map.\r\n\r\n\r\npop_tol <- 0.01\r\nsubparpop <- sum(sub$pop)/3\r\nparpop <- sum(nc_shp$pop)/13\r\n\r\nsub_pop_tol <-  min(abs(subparpop - parpop * (1 - pop_tol)),\r\n                abs(subparpop - parpop * (1 + pop_tol))) / subparpop\r\nsub_pop_tol\r\n\r\n\r\n[1] 0.009639859\r\n\r\nNow we can simulate again, but on the smaller map.\r\n\r\n\r\nsims_sub <- redist.smc(adj = sub_adj, total_pop = sub$pop,\r\n                      nsims = 1000,  ndists = 3, counties = match(sub$county, unique(sub$county)),\r\n                      pop_tol = sub_pop_tol, silent = TRUE)\r\n\r\n\r\n\r\nAs before, we have to compute metrics for both the reference plan and the simulated plans.\r\n\r\n\r\nsub_metrics <- redist.metrics(plans = sims_sub$plans, measure = 'DVS', \r\n                          rvote = sub$el14g_uss_r, sub$el14g_uss_d)\r\n\r\nsub_sorted <- sub_metrics %>% \r\n  group_by(draw) %>% \r\n  arrange(DVS,.by_group = TRUE) %>% \r\n  mutate(district = 1:3) %>% \r\n  ungroup()\r\n\r\nsub_reference_metrics <- redist.metrics(plans = match(sub$cd_17, unique(sub$cd_17)), \r\n                                    measure = 'DVS', \r\n                                    rvote = sub$el14g_uss_r, dvote = sub$el14g_uss_d)\r\n\r\nsub_sorted_reference <- sub_reference_metrics %>% arrange(DVS) %>% mutate(district = 1:3)\r\n\r\n\r\n\r\nAnd finally, we can plot the metrics and manually add the reference points.\r\n\r\n\r\nsub_sorted %>% ggplot(aes(x = district, y = DVS, group = district)) + \r\n  geom_boxplot() + \r\n  theme_minimal() + \r\n  labs(x = 'District, sorted by DVS') + \r\n  geom_segment(data = sub_sorted_reference, size = 1,\r\n               aes(x = district - 0.35, xend = district + 0.35, yend = DVS, color = 'red')) + \r\n  scale_color_manual(name = '', values = c('red' = 'red'),\r\n  labels = c('ref'), guide = 'legend')\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2021-04-02-redist-300/redist-300_files/figure-html5/unnamed-chunk-2-1.png",
    "last_modified": "2021-04-03T00:24:27-04:00",
    "input_file": "redist-300.utf8.md",
    "preview_width": 1248,
    "preview_height": 768
  }
]
