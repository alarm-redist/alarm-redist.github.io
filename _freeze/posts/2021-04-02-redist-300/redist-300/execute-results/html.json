{
  "hash": "84c2db070f68fff0ace4651cf6356c77",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"redist 3.0\"\ndescription: |\n  A major release brings new algorithms, new workflows, and significant\n  usability improvements.\nauthor:\n  - name: Cory McCartan\n    affiliation: Department of Statistics, Harvard University\n    url: https://corymccartan.github.io/\n  - name: Christopher Kenny\n    affiliation: Department of Government, Harvard University\n    url: https://www.christophertkenny.com/\ndate: April 7, 2021\npreview: https://alarm-redist.github.io/posts/2021-08-10-census-2020/graphic.png\n---\n\n\n\n\n\nThe ALARM Project is excited to announce the release of\n[**redist** 3.0](https://alarm-redist.github.io/redist/) on CRAN. This release\nbrings with it new algorithms and major new workflow improvements, making\nredistricting analysis broadly accessible to data scientists everywhere.\n\n![](/redist/reference/figures/map_photo.jpg)\n\nInstall the new version with `install.packages(\"redist\")`.\n\n\n# New Features\nThis release includes far too many changes to list comprehensively.  Key\nimprovements and new features include:\n\n- New tidy interface, including new\n[`redist_map`](/redist/reference/redist_map.html) and\n[`redist_plans`](/redist/reference/redist_plans.html) objects\n- Merge-split MCMC now available in [`redist_mergesplit()`](/redist/reference/redist_mergesplit.html)\n- Short burst MCMC optimization now available in\n[`redist_shortburst()`](/redist/reference/redist_shortburst.html)\nalong with [scoring functions](/redist/reference/scorers.html)\n- Improved [Flip MCMC interface](/redist/reference/redist_flip.html)\n  and performance improvements\n- New support for larger simulation size limits\n- Functions to [freeze parts of a map](/redist/reference/redist.freeze.html)\n  and extract [district cores](/redist/reference/redist.identify.cores.html)\n- New [VRA constraint](/redist/reference/redist_smc.html#details)\n- Many new [plotting functions](/redist/reference/index.html#section-plotting-tools)\n- Consistent function and argument [names](/redist/articles/glossary.html)\n- New [partisanship](/redist/reference/redist.metrics.html)\n  and [compactnes](/redist/reference/redist.compactness.html) metrics\n- Performance improvements to compactness calculations\n- Plan comparison and classification in\n  [`compare_plans()`](/redist/reference/compare_plans.html) and\n  [`classify_plans()`](/redist/reference/classify_plans.html)\n- New [`iowa`](/redist/reference/iowa.html) dataset and cleaned-up package data\n\nTo begin exploring the new features, check out the new\n[Get Started](/redist/articles/redist.html) vignette.\n\n# Workflow Example: North Carolina\n\nTo demonstrate the new `redist` workflow, we'll run through a basic analysis\nof the 2017 congressional districts of the state of North Carolina, which\nwere [struck down as an unconstitutional partisan gerrymander](https://www.nbcnews.com/politics/politics-news/north-carolina-judges-toss-maps-slam-gerrymandering-stinging-ruling-n1049411)\nin 2019.\n\n## New workflow\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(redist)\n\ndownload.file(\"https://github.com/alarm-redist/redist-data/raw/main/data/nc.rds\",\n              data_path <- tempfile())\nnc_shp <- readRDS(data_path) %>%\n    select(vtd:vap, el14g_uss_r:geometry)\n```\n:::\n\n\n\nUnder the new workflow, a redistricting analysis begins with a `redist_map`\nobject, which defines the basic parameters of the redistricting problem.\nThe `redist_map()` constructor builds the precinct adjacency graph which is\nrequired for redistricting simulation, and stores relevant metadata, such as\nthe desired population parity tolerance and a reference to the existing\ndistricts. It also comes with helpful plotting functions.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnc = redist_map(nc_shp, existing_plan=cd_17, pop_tol=0.01)\nprint(nc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTo be partitioned into 13 districts with population between 733,498.7 - 1.0% and 733,498.7 + 1.0%\nWith geometry:\n    bbox:           xmin: 406819.6 ymin: 2696.2 xmax: 3070217 ymax: 1043629\n    projected CRS:  NAD83(HARN) / North Carolina (ftUS)\n# A tibble: 2,692 × 15\n   vtd       county   pop   vap el14g_uss_r el14g_uss_d el14g_uss_l el14g_uss_wi\n * <chr>     <chr>  <int> <int>       <int>       <int>       <int>        <int>\n 1 3700106W  37001   1973  1505         181         182          17            1\n 2 3700112E  37001   3391  2503         180         271          21            0\n 3 3700112W  37001   2744  2156         457         481          42            1\n 4 3700106N  37001   4468  3167         231         466          31            2\n 5 37001126  37001   2038  1713         670         416          38            0\n 6 37001124  37001   2455  1948         491         391          33            1\n 7 370011210 37001   2802  2127         358         309          31            0\n 8 3700103N  37001   5712  4955        1063         853          53            3\n 9 3700102   37001   4491  3483        1246         313          62            2\n10 3700106E  37001   3113  2371         423         432          42            4\n# ℹ 2,682 more rows\n# ℹ 7 more variables: el14g_uss_tot <int>, cd_13 <int>, cd_17 <int>,\n#   aland10 <dbl>, awater10 <dbl>, geometry <MULTIPOLYGON [US_survey_foot]>,\n#   adj <list>\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(nc, el14g_uss_d/(el14g_uss_d+el14g_uss_r)) +\n    scale_fill_gradient2(midpoint=0.5)\n```\n\n::: {.cell-output-display}\n![](redist-300_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\nOnce we've created a `redist_map` object, we can simulate redistricting plans.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplans = redist_smc(nc, 1000, counties=county, silent=TRUE) # 1000 plans\nprint(plans)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nA <redist_plans> containing 1,000 sampled plans and 1 reference plan\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nPlans have 13 districts from a 2,692-unit map, and were drawn using Sequential\nMonte Carlo.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWith plans resampled from weights\nPlans matrix: int [1:2692, 1:1001] 1 1 1 1 1 1 1 1 1 1 ...\n# A tibble: 13,013 × 3\n   draw  district total_pop\n   <fct>    <int>     <dbl>\n 1 cd_17        1    733554\n 2 cd_17        2    733879\n 3 cd_17        3    731507\n 4 cd_17        4    732627\n 5 cd_17        5    733323\n 6 cd_17        6    734750\n 7 cd_17        7    736057\n 8 cd_17        8    733447\n 9 cd_17        9    734777\n10 cd_17       10    729710\n# ℹ 13,003 more rows\n```\n\n\n:::\n:::\n\n\n\nThe `plans` variable is a `redist_plans` object---a special container designed\nto make handling sets of redistricting plans painless. As the output above\nshows, `plans` contains the 1,000 samppled plans, plus the 2017 congressional\ndistricts.  We can plot a few of these plans.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nredist.plot.plans(plans, draws=c(\"cd_17\", \"1\", \"2\", \"3\"), geom=nc)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in redist.plot.plans(plans, draws = c(\"cd_17\", \"1\", \"2\", \"3\"), geom = nc): 'geom' is deprecated.\nUse 'shp' instead.\nSee help(\"Deprecated\")\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](redist-300_files/figure-html/nc-plans-1.png){width=768}\n:::\n:::\n\n\n\nA `redist_plans` object makes it easy to compute plan and district summary\nstatistics.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplans = plans %>%\n    mutate(comp = distr_compactness(nc),\n           dem_share = group_frac(nc, el14g_uss_d, el14g_uss_d + el14g_uss_r))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: There were 2 warnings in `\"draw\" %in% names(data)`.\nThe first warning was:\nℹ In argument: `comp = distr_compactness(nc)`.\nCaused by warning in `distr_compactness()`:\n! 'distr_compactness' is deprecated.\nSee help(\"Deprecated\")\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(plans)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nA <redist_plans> containing 1,000 sampled plans and 1 reference plan\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nPlans have 13 districts from a 2,692-unit map, and were drawn using Sequential\nMonte Carlo.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWith plans resampled from weights\nPlans matrix: int [1:2692, 1:1001] 1 1 1 1 1 1 1 1 1 1 ...\n# A tibble: 13,013 × 5\n   draw  district total_pop  comp dem_share\n   <fct>    <int>     <dbl> <dbl>     <dbl>\n 1 cd_17        1    733554 0.951     0.441\n 2 cd_17        2    733879 0.951     0.425\n 3 cd_17        3    731507 0.951     0.440\n 4 cd_17        4    732627 0.951     0.407\n 5 cd_17        5    733323 0.951     0.687\n 6 cd_17        6    734750 0.951     0.446\n 7 cd_17        7    736057 0.951     0.419\n 8 cd_17        8    733447 0.951     0.416\n 9 cd_17        9    734777 0.951     0.439\n10 cd_17       10    729710 0.951     0.458\n# ℹ 13,003 more rows\n```\n\n\n:::\n:::\n\n\n\nFrom there, we can quickly generate informative plots. First we check the\ncompactness of the generated plans, and see that they are significantly more\ncompact than the adopted 2017 plan.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(plans, comp) +\n    labs(x=\"Compactness score (higher is more compact)\")\n```\n\n::: {.cell-output-display}\n![](redist-300_files/figure-html/nc-comp-1.png){width=672}\n:::\n:::\n\n\n\nNext, we look at the partisan implications of the 2017 plan. We plot the\ntwo-party Democratic vote share in each district, with districts sorted by\nthis quantity. Each dot on the plot below is a district from one simulated plan,\nand the red lines show the values for the 2017 plan.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| fig-width: 8\nredist.plot.distr_qtys(plans, dem_share, size=0.1)\n```\n\n::: {.cell-output-display}\n![](redist-300_files/figure-html/nc-dem-1.png){width=672}\n:::\n:::\n\n\n\nWe see immediately that the 2017 plan packs Democratic voters into the three\nmost Democratic districts, and cracks them in the remaining 10 districts,\nleading to a durable 10--3 Republican-Democratic seat split (in an election\nwhich Democrats captured\n49%\nof the statewide two-party vote). A clear partisan gerrymander.\n\n### Studying districts 1, 2, and 4\nIf we want to study a specific set of districts, we can quickly `filter()` to\nthe relevant map area and re-run the analysis. The `redist_map()` object will\nhandle all appropriate adjustments to the adjacency graph, number of districts,\nand population tolerance (as is visible below).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnc_sub = filter(nc, cd_17 %in% c(1, 2, 4))\nprint(nc_sub)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nA <redist_map> with 571 units and 15 fields\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTo be partitioned into 3 districts with population between 733,498.7 - 1.0% and 733,498.7 + 1.0%\nWith geometry:\n    bbox:           xmin: 1921644 ymin: 524882.4 xmax: 2784102 ymax: 1028248\n    projected CRS:  NAD83(HARN) / North Carolina (ftUS)\n# A tibble: 571 × 15\n   vtd     county   pop   vap el14g_uss_r el14g_uss_d el14g_uss_l el14g_uss_wi\n * <chr>   <chr>  <int> <int>       <int>       <int>       <int>        <int>\n 1 37015C2 37015   2182  1707         174         503          13            0\n 2 37015M1 37015   1103   849         172         167           5            0\n 3 37015C1 37015   1229   986         229         184          11            0\n 4 37015MH 37015    992   811         146         254          12            0\n 5 37015W2 37015    966   764         286          47          20            0\n 6 37015W1 37015   7005  5703         596        1190          44            2\n 7 37015M2 37015   1290   983          99         239          16            0\n 8 37015SN 37015   1410  1025          63         327          11            0\n 9 37015WH 37015   1554  1274         292         262          12            0\n10 37015WD 37015   1409  1050          35         319           5            0\n# ℹ 561 more rows\n# ℹ 7 more variables: el14g_uss_tot <int>, cd_13 <int>, cd_17 <int>,\n#   aland10 <dbl>, awater10 <dbl>, geometry <MULTIPOLYGON [US_survey_foot]>,\n#   adj <list>\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(nc_sub)\n```\n\n::: {.cell-output-display}\n![](redist-300_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\nOn this subset, too, the adopted 2017 plan is a significant outlier.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplans_sub = redist_smc(nc_sub, 1000, counties=county, silent=T) %>%\n    mutate(dem_share = group_frac(nc_sub, el14g_uss_d, el14g_uss_d + el14g_uss_r))\nredist.plot.distr_qtys(plans_sub, dem_share, size=0.3)\n```\n\n::: {.cell-output-display}\n![](redist-300_files/figure-html/nc-sub-1.png){width=672}\n:::\n:::\n\n\n\n## Old workflow\n\nIn comparison, the old workflow required significantly more steps and manual\nprocessing.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(redist)\n\ndownload.file(\"https://github.com/alarm-redist/redist-data/raw/main/data/nc.rds\",\n              data_path <- tempfile())\nnc_shp <- readRDS(data_path) %>%\n    select(vtd:vap, el14g_uss_r:geometry)\n```\n:::\n\n\n\nOnce we've downloaded the data, we can start by building the adjacency graph.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadj <- redist.adjacency(nc_shp)\n```\n:::\n\n\n\nTime to first simulation was never really the issue, however each simulation\nrequired many inputs. `redist_map` objects keep track of the `adj`, `total_pop`,\n`ndists`, and `pop_tol` arguments, but in the older version, you had to specify\neach of these for every simulation. One of the quirky aspects of the older\nversion was that `counties` needed to be a vector with values `1:n_counties`,\nmeaning that you had to manually transform it to use it and that only worked if\nthe counties were contiguous.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsims <- redist.smc(adj = adj, total_pop = nc_shp$pop, ndists = 13,\n                   pop_tol = 0.01,\n                   counties = match(nc_shp$county, unique(nc_shp$county)),\n                   nsims = 1000, silent = TRUE)\n```\n:::\n\n\n\nOnce you finished simulating, setting up plots was always a hassle, as you\nneeded to plot both the distribution of simulations and then compute the same\nmetric separately for the reference plan, in this case that's the 2017\ncongressional districts.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmetrics <- redist.metrics(plans = sims$plans, measure = 'DVS',\n                          rvote = nc_shp$el14g_uss_r, nc_shp$el14g_uss_d)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in redist.metrics(plans = sims$plans, measure = \"DVS\", rvote = nc_shp$el14g_uss_r, : 'redist.metrics' is deprecated.\nUse 'part_dvs' instead.\nSee help(\"Deprecated\")\n```\n\n\n:::\n\n```{.r .cell-code}\nsorted <- metrics %>%\n  group_by(draw) %>%\n  arrange(DVS,.by_group = TRUE) %>%\n  mutate(district = 1:13) %>%\n  ungroup()\n\nreference_metrics <- redist.metrics(plans = nc_shp$cd_17,\n                                    measure = 'DVS',\n                                    rvote = nc_shp$el14g_uss_r,\n                                    dvote = nc_shp$el14g_uss_d)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in redist.metrics(plans = nc_shp$cd_17, measure = \"DVS\", rvote = nc_shp$el14g_uss_r, : 'redist.metrics' is deprecated.\nUse 'part_dvs' instead.\nSee help(\"Deprecated\")\n```\n\n\n:::\n\n```{.r .cell-code}\nsorted_reference <- reference_metrics %>%\n    arrange(DVS) %>%\n    mutate(district = 1:13)\n```\n:::\n\n\n\nAnd then to plot the standard stacked boxplots, you would need to add the\nreference plan manually to the rest.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsorted %>% ggplot(aes(x = district, y = DVS, group = district)) +\n  geom_boxplot() +\n  theme_minimal() +\n  labs(x = 'District, sorted by DVS') +\n  geom_segment(data = sorted_reference, size = 1,\n               aes(x = district - 0.35, xend = district + 0.35,\n                   yend = DVS, color = 'red')) +\n  scale_color_manual(name = '', values = c('red' = 'red'),\n  labels = c('ref'), guide = 'legend')\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](redist-300_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\n\n### Studying districts 1, 2, and 4\nThe steps between loading in data to your first simulation wasn't terrible in\nthe old version when you were working with the full map. However, when trying to\nwork with subsets, it became messy.\n\nFirst you needed to subset the shape and then rebuild a new adjacency graph that\nonly had the remaining precincts.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsub <- nc_shp %>% filter(cd_17 %in% c(1, 2, 4))\nsub_adj <- redist.adjacency(sub)\n```\n:::\n\n\n\nThen, if your target on the full map was 1\\%, you had to compute the equivalent\non the subset map, as a 1\\% population deviation on a subset is often larger\nonce recombined with the full map.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop_tol <- 0.01\nsubparpop <- sum(sub$pop)/3\nparpop <- sum(nc_shp$pop)/13\n\nsub_pop_tol <-  min(abs(subparpop - parpop * (1 - pop_tol)),\n                abs(subparpop - parpop * (1 + pop_tol))) / subparpop\nsub_pop_tol\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.009639859\n```\n\n\n:::\n:::\n\n\n\n\nNow we can simulate again, but on the smaller map.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsims_sub <- redist.smc(adj = sub_adj, total_pop = sub$pop,\n                      nsims = 1000,  ndists = 3,\n                      counties = match(sub$county, unique(sub$county)),\n                      pop_tol = sub_pop_tol, silent = TRUE)\n```\n:::\n\n\n\n\nAs before, we have to compute metrics for both the reference plan and the simulated plans.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsub_metrics <- redist.metrics(plans = sims_sub$plans, measure = 'DVS',\n                              rvote = sub$el14g_uss_r, sub$el14g_uss_d)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in redist.metrics(plans = sims_sub$plans, measure = \"DVS\", rvote = sub$el14g_uss_r, : 'redist.metrics' is deprecated.\nUse 'part_dvs' instead.\nSee help(\"Deprecated\")\n```\n\n\n:::\n\n```{.r .cell-code}\nsub_sorted <- sub_metrics %>%\n  group_by(draw) %>%\n  arrange(DVS,.by_group = TRUE) %>%\n  mutate(district = 1:3) %>%\n  ungroup()\n\nsub_reference_metrics <- redist.metrics(plans = match(sub$cd_17,\n                                                      unique(sub$cd_17)),\n                                        measure = 'DVS',\n                                        rvote = sub$el14g_uss_r,\n                                        dvote = sub$el14g_uss_d)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in redist.metrics(plans = match(sub$cd_17, unique(sub$cd_17)), measure = \"DVS\", : 'redist.metrics' is deprecated.\nUse 'part_dvs' instead.\nSee help(\"Deprecated\")\n```\n\n\n:::\n\n```{.r .cell-code}\nsub_sorted_reference <- sub_reference_metrics %>%\n    arrange(DVS) %>%\n    mutate(district = 1:3)\n```\n:::\n\n\n\nAnd finally, we can plot the metrics and manually add the reference points.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsub_sorted %>% ggplot(aes(x = district, y = DVS, group = district)) +\n  geom_boxplot() +\n  theme_minimal() +\n  labs(x = 'District, sorted by DVS') +\n  geom_segment(data = sub_sorted_reference, size = 1,\n               aes(x = district - 0.35, xend = district + 0.35,\n                   yend = DVS, color = 'red')) +\n  scale_color_manual(name = '', values = c('red' = 'red'),\n  labels = c('ref'), guide = 'legend')\n```\n\n::: {.cell-output-display}\n![](redist-300_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}